type Point = Tuple<int32, int32>
type Line = Tuple<float32, float32, float32>

function normalized: Tuple<float, float> -> Tuple<float, float>
function rotated90: Tuple<float, float> -> Tuple<float, float>
function raster: (Point, Point) -> Tuple<Array(l)<int32>, Array(l)<int32>>
function distance_vectorized: (Array(l, 2)<int32>, Point) -> Array(l)<float32>


Inputs:
    binary_img: Array(R, C)<uint8>
    chip_curve_pts: Array(H, 1, 2)<int32>
    chip_pts: Array(N, 1, 2)<int32>
    thickness_majorant: int


// O(hull_length * thickness_majorant)  ~=  O(N)
// measure the thickness of the chip along its curve

chip_thickness = new MutableSequence<float32>
chip_inside_contour_pts = new MutableSequence<Point>

for i in range(H-1):
    a: Point = chip_curve_pts[i, 0, :]
    b: Point = chip_curve_pts[i+1, 0, :]
    n: Tuple[float, float] = normalized(rotated90(b - a))
    c: Point = a + thickness_majorant * n
    d: Point = b + thickness_majorant * n

    for (p0: Point, p1: Point) in zip(zip(*raster(a, b), zip(*raster(c, d)))):
        ray_x: Array(T)<int32>, ray_y: Array(T)<int32> = raster(p0, p1)

        selected_idx: Array(T)<int> = np.nonzero(binary_img[ray_x, ray_y])
        if T > 0:
            selected_x: Array(S)<int32>, selected_y: Array(S)<int32> = ray_x[selected_idx], ray_y[selected_idx]
            selected_pts: Array(S, 2)<int32> = column_stack((selected_x, selected_y))

            distances: Array(S)<float32> = distance_vectorized(selected_pts, p0)
            // distances = new Array(S)<float32>
            // for i in range(S):
            //     p: Point = (selected_x[i], selected_y[i])
            //     distances[i] = distance(p, p0)

            furthest_p_idx: int = argmax(distances)
            chip_thickness.append(distances[furthest_p_idx])
            chip_inside_contour_pts.append(selected_pts[furthest_p_idx])


Outputs:
    chip_thickness: Sequence<float32>
    chip_inside_contour_pts: Sequence<Point>
