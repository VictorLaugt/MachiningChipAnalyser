type Point = Tuple<int32, int32>
type Line = Tuple<float32, float32, float32>


chip_pts: Array(N, 1, 2)<int32> = ...
chip_hull_pts: Array(H, 1, 2)<int32> = ...


// O(H)
// create edge lines
edge_lines = new MutableSequence<Line>
for i in range(H-1):
    p0, p1 = chip_hull_pts[i, 0, :], chip_hull_pts[i+1, 0, :]
    edge_lines.append(line_from_two_points(p0, p1))


// O(H*N)
// compute distance from each edge to each chip point
dist_edge_pt = new Array(H-1, N)<float32>
for i in range(H-1):
    dist_edge_pt[i, :] = distance_vectorized(chip_pts, edge_lines[i])
    // for j in range(N):
    //     dist_edge_pt[i, j] = distance(chip_pts[j], edge_lines[i])


// O(H*N)
// find the nearest edge of each chip point
nearest_edge_idx: Array(N)<int32> = argmin(dist_edge_pt, axis=0)
// nearest_edge_idx = new Array(N)<int32>
// for j in range(N):
//     nearest_edge_idx[j] = argmin(dist_edge_pt[:, j])


// O(N)
// measure the thickness of the chip along its curve
// if `e` is a point from an edge, then
// `opposite[e]` is the closest point from `chip_pts` in front of `e` and
// `thickness[e]` is its distance from `e`
opposite = new HashMap<Point, Point>
thickness = new HashMap<Point, float32>

for j in range(N):
    p = chip_pts[j, 0, :]
    nearest_edge = edge_lines[nearest_edge_idx[j]]
    dist, e = orthogonal_projection(p, nearest_edge)

    max_dist = thickness.get(e, -1.0)
    if dist > max_dist:
        thickness[e] = dist
        opposite[e] = p

chip_thickness = new Sequence<float32>(thickness.values())
chip_inside_pts = new Sequence<Point>(opposite.values())

